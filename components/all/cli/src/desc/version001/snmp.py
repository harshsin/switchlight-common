# Copyright (c) 2013-2014 BigSwitch Networks

import command
import run_config
import subprocess
from sl_util import Service, utils, const, conf_state
import utif
import cfgfile
import error
from switchlight.platform.base import *
from switchlight.platform.current import SwitchLightPlatform

Platform=SwitchLightPlatform()

LINK_UP_DOWN_CLI              = 'linkUpDown'
#Used to be: LINK_UP_DOWN_NOTIFICATION_CMD = 'linkUpDownNotifications'
#Now using other cmds to allow polling interval setting. See 'man snmpd.conf'
trapLinkUp    = '.1.3.6.1.6.3.1.1.5.4'
trapLinkDown  = '.1.3.6.1.6.3.1.1.5.3'
ifIndex       = '.1.3.6.1.2.1.2.2.1.1'
ifAdminStatus = '.1.3.6.1.2.1.2.2.1.7'
ifOperStatus  = '.1.3.6.1.2.1.2.2.1.8'
LINK_UP_NOTIFICATION   = 'notificationEvent linkUpTrap %s %s %s %s\n' % \
    (trapLinkUp, ifIndex, ifAdminStatus, ifOperStatus)
LINK_DOWN_NOTIFICATION = 'notificationEvent linkDownTrap %s %s %s %s\n' % \
    (trapLinkDown, ifIndex, ifAdminStatus, ifOperStatus)
LINK_UP_MONITOR   = 'monitor -r %%d -e linkUpTrap "Generate linkUp" %s != 2\n' % ifOperStatus
LINK_UP_MONITOR_CMD_ID = "Generate linkUp"
LINK_UP_MONITOR_TOKEN_NUM = len(LINK_UP_MONITOR.split(' '))
LINK_DOWN_MONITOR = 'monitor -r %%d -e linkDownTrap "Generate linkDown" %s == 2\n' % ifOperStatus
LINK_DOWN_MONITOR_CMD_ID = "Generate linkDown"

AUTH_FAIL_CLI = 'authenticationFailure'
AUTH_FAIL_NOTIFICATION = 'authtrapenable 1\n'
AUTH_FAIL_NOTIFICATION_TOKEN_NUM = len(AUTH_FAIL_NOTIFICATION.split(' '))

# Platform config OIDs file
# generated by ONLdump
PF_CONFIG_OID_FILE = '/lib/platform-config/current/oids'

# Put all OID CLI strings into this class like a summary of what 
# we support in CLI instead of going through the long CLI structures.
# These strings are used for CLI and some reverse CLI mapping
class oidstr(object):
    PREFIX='prefix'
    STATUS='status'
    STATUS_GOOD='good'
    STATUS_FAILED='failed'
    STATUS_PRESENT='present'
    STATUS_MISSING='missing'
    STATUS_PLUGGED_IN='plugged_in'
    STATUS_UNPLUGGED='unplugged'
    NAME_TO_INDEX_MAP='name2index'
    VALUE='value'
    THERMAL_CMD='Thermal'
    THERMAL_STATUS=STATUS
    THERMAL_TEMP='temperature'
    FAN_CMD='Fan'
    FAN_STATUS=STATUS
    FAN_RPM='rpm'
    FAN_PERCENTAGE='percentage'
    PSU_CMD='PSU'
    PSU_STATUS=STATUS
    PSU_VIN='Vin'
    PSU_VOUT='Vout'
    PSU_IIN='Iin'
    PSU_IOUT='Iout'
    PSU_PIN='Pin'
    PSU_POUT='Pout'
    CPU_LOAD='cpu-load'
    MEM_TOTAL_FREE='mem-total-free'
    INTERFACES='interfaces'
    FLOW_TABLE_L2_UTILIZATION='flow-table-l2-util'
    FLOW_TABLE_TCAM_FM_UTILIZATION='flow-table-tcam-fm-util'
    LINK_TABLE_UTILIZATION='link-table-util'
    
#from MIB file
BSN_SL_SENSOR_OID_SENSORS = '.1.3.6.1.4.1.37538.2.3'
BSN_SL_SENSOR_OID_TEMP_IDX = BSN_SL_SENSOR_OID_SENSORS + '.1.1'
BSN_SL_SENSOR_OID_TEMP_IDX_STATUS = '.3'
BSN_SL_SENSOR_OID_TEMP_IDX_VALUE    = '.4'
BSN_SL_SENSOR_OID_FAN_IDX = BSN_SL_SENSOR_OID_SENSORS + '.2.1'
BSN_SL_SENSOR_OID_FAN_IDX_STATUS = '.3'
BSN_SL_SENSOR_OID_FAN_IDX_RPM    = '.5'
BSN_SL_SENSOR_OID_FAN_IDX_PERCENTAGE = '.6'
BSN_SL_SENSOR_OID_PSU_IDX = BSN_SL_SENSOR_OID_SENSORS + '.3.1'
BSN_SL_SENSOR_OID_PSU_IDX_STATUS = '.3'
BSN_SL_SENSOR_OID_PSU_IDX_VIN = '.6'
BSN_SL_SENSOR_OID_PSU_IDX_VOUT = '.7'
BSN_SL_SENSOR_OID_PSU_IDX_IIN = '.8'
BSN_SL_SENSOR_OID_PSU_IDX_IOUT = '.9'
BSN_SL_SENSOR_OID_PSU_IDX_PIN = '.10'
BSN_SL_SENSOR_OID_PSU_IDX_POUT = '.11'

BSN_SL_SENSOR_OID_TABLE = {
    oidstr.THERMAL_CMD : {
        oidstr.PREFIX          : BSN_SL_SENSOR_OID_TEMP_IDX,
        oidstr.THERMAL_STATUS  : BSN_SL_SENSOR_OID_TEMP_IDX + BSN_SL_SENSOR_OID_TEMP_IDX_STATUS,
        oidstr.THERMAL_TEMP    : BSN_SL_SENSOR_OID_TEMP_IDX + BSN_SL_SENSOR_OID_TEMP_IDX_VALUE,
        oidstr.STATUS_GOOD     : 1,
        oidstr.STATUS_FAILED   : 2,
        oidstr.STATUS_MISSING  : 0,
        },

    oidstr.FAN_CMD : {
        oidstr.PREFIX         : BSN_SL_SENSOR_OID_FAN_IDX,
        oidstr.FAN_STATUS     : BSN_SL_SENSOR_OID_FAN_IDX + BSN_SL_SENSOR_OID_FAN_IDX_STATUS,
        oidstr.FAN_RPM        : BSN_SL_SENSOR_OID_FAN_IDX + BSN_SL_SENSOR_OID_FAN_IDX_RPM,
        oidstr.FAN_PERCENTAGE : BSN_SL_SENSOR_OID_FAN_IDX + BSN_SL_SENSOR_OID_FAN_IDX_PERCENTAGE,
        oidstr.STATUS_GOOD    : 1,
        oidstr.STATUS_FAILED  : 2,
        oidstr.STATUS_MISSING : 0,      
        },
    
    oidstr.PSU_CMD : {
        oidstr.PREFIX       : BSN_SL_SENSOR_OID_PSU_IDX,
        oidstr.PSU_STATUS   : BSN_SL_SENSOR_OID_PSU_IDX + BSN_SL_SENSOR_OID_PSU_IDX_STATUS,
        oidstr.PSU_VIN      : BSN_SL_SENSOR_OID_PSU_IDX + BSN_SL_SENSOR_OID_PSU_IDX_VIN,
        oidstr.PSU_VOUT     : BSN_SL_SENSOR_OID_PSU_IDX + BSN_SL_SENSOR_OID_PSU_IDX_VOUT,
        oidstr.PSU_IIN      : BSN_SL_SENSOR_OID_PSU_IDX + BSN_SL_SENSOR_OID_PSU_IDX_IIN,
        oidstr.PSU_IOUT     : BSN_SL_SENSOR_OID_PSU_IDX + BSN_SL_SENSOR_OID_PSU_IDX_IOUT,
        oidstr.PSU_PIN      : BSN_SL_SENSOR_OID_PSU_IDX + BSN_SL_SENSOR_OID_PSU_IDX_PIN,
        oidstr.PSU_POUT     : BSN_SL_SENSOR_OID_PSU_IDX + BSN_SL_SENSOR_OID_PSU_IDX_POUT,
        oidstr.STATUS_GOOD    : 1,
        oidstr.STATUS_FAILED  : 2,
        oidstr.STATUS_MISSING : 0,
        },
    
    oidstr.CPU_LOAD : {
        'cpuload'        : '.1.3.6.1.4.1.2021.10.1.5.1',
        },

    oidstr.MEM_TOTAL_FREE : {
        'memtotalfree'   : '.1.3.6.1.4.1.2021.4.11.0',
        },

    oidstr.INTERFACES: {
        'interfaces'     : '.1.3.6.1.2.1.2',
        },

    oidstr.FLOW_TABLE_L2_UTILIZATION : {
        'ft_l2_utilization'    : '.1.3.6.1.4.1.37538.2.1.1.3',
        },

    oidstr.FLOW_TABLE_TCAM_FM_UTILIZATION : {
        'ft_tcam_fm_utilization'    : '.1.3.6.1.4.1.37538.2.1.2.3',
        },

    oidstr.LINK_TABLE_UTILIZATION : {
        'ft_link_utilization'    : '.1.3.6.1.4.1.37538.2.2.1.3',
        },
    }

# We can put the range in here
# In the future we can read info from ONLdump
# This is a subject to change
BSN_SL_SENSOR_RANGE_TABLE = {
    oidstr.THERMAL_CMD : {
        oidstr.THERMAL_TEMP    : (0, 300000)
        },

    oidstr.FAN_CMD : {
        oidstr.FAN_RPM        : (0, 100000),
        oidstr.FAN_PERCENTAGE : (0, 100)    
        },
    
    oidstr.PSU_CMD : {
        oidstr.PSU_VIN      : (0, 240000),
        oidstr.PSU_VOUT     : (0, 240000),
        oidstr.PSU_IIN      : (0, 10000),
        oidstr.PSU_IOUT     : (0, 10000),
        oidstr.PSU_PIN      : (0, 1000000),
        oidstr.PSU_POUT     : (0, 1000000),
        },
    }

def trap_sensor_range_get(sensor_cmd, sensor_info):
    return BSN_SL_SENSOR_RANGE_TABLE[sensor_cmd][sensor_info]

class Snmp(Service):
    SVC_NAME = "snmpd"
    CFG_PATH = const.SNMP_CFG_PATH

conf_state.register_save("snmp", Snmp.save_default_settings)
conf_state.register_revert("snmp", Snmp.revert_default_settings)

def get_snmp_status():
    st = Snmp.status()
    if st == Service.HALTED:
        status = 'disabled'
    elif st == Service.RUNNING:
        status = 'enabled'
    else:
        status = "ERROR"
    return status

# datakeywords to parse CLI data dict parameter.
# snmpkeywords to parse snmpd.conf.
# datakeywords and snmpkeywords must be in 1-to-1 correspondance
#   e.g. value of data['location'] is value of 'sysLocation' in snmpd.conf
datakeywords = ['contact', 'location']
snmpkeywords = ['sysContact', 'sysLocation']

def parse_snmpd_conf(lines):
    """
    Return a dict whose keys are those in "datakeywords" above,
    and whose values are (associated value, index in "lines") tuples.
    """
    dt = {}
    for (idx, line) in enumerate(lines):
        tokens = line.split(None, 1)
        if len(tokens) == 2 and tokens[0] in snmpkeywords:
            # WARNING no handling of other rocommunity/rwcommunity params
            val = tokens[1].strip()
            dt[datakeywords[snmpkeywords.index(tokens[0])]] = (val, idx)
    return dt


def show_snmp_server(data):
    try:
        with cfgfile.FileLock(Snmp.CFG_PATH) as f:
            lines = cfgfile.get_line_list_from_file(f)
    except:
        raise error.ActionError('Cannot access SNMP configuration')

    cfg = parse_snmpd_conf(lines)

    print "status:  %s" % get_snmp_status()
    print "configuration:"
    for key in datakeywords:
        if key in cfg:
            print '  %-12s  %s' % (key, cfg[key][0])
    print '  communities:'
    for  li in lines:
        w = li[:-1].split(' ')
        if 'community' in w[0]:
            print '    %s %s' % (w[1], w[0][:2])
    print '  trap/inform destinations:'
    for li in lines:
        w = li[:-1].split(' ')
        if w[0] == 'trap2sink':
            ww = w[1].split(':')
            print '    host %s traps %s udp-port %s' % (ww[0], w[2], ww[1])
            continue
        if w[0] == 'informsink':
            ww = w[1].split(':')
            print '    host %s informs %s udp-port %s' % (ww[0], w[2], ww[1])
            continue
    print '  traps:'
    for li in lines:
        w = li[:-1].split(' ')
        if w[0] == 'authtrapenable' and \
                len(w) == AUTH_FAIL_NOTIFICATION_TOKEN_NUM and w[1] == '1':
            print '    authentification failure'
            continue
        if w[0] == 'monitor' and len(w) == LINK_UP_MONITOR_TOKEN_NUM:
            # The command linkUpDown results 2 monitor commands
            # and we print only 1 of them
            if w[4] == 'linkUpTrap':
                print '    %s, interval %s' % (LINK_UP_DOWN_CLI, w[2])
            continue
        if w[0] == 'monitor':
            if w[1] == '-r':
                trap_cmd = w[4].replace("_", " ")
                print '    %s, interval %s' % (trap_cmd, w[2])
            else:
                trap_cmd = w[2].replace("_", " ")
                print '    %s' % (trap_cmd)
            continue


command.add_action('implement-show-snmp-server', show_snmp_server,
                    {'kwargs': {'data'      : '$data',}})

SHOW_SNMP_SERVER_COMMAND_DESCRIPTION = {
    'name'         : 'show',
    'mode'         : 'login',
    'action'       : 'implement-show-snmp-server',
    'no-supported' : False,
    'args'         : (
        {
            'token'       : 'snmp-server',
            'short-help'  : 'Show the current SNMP server configuration',
            'doc'         : 'snmp|show',
        },
    )
}


def enable_snmp(no_command, data):
    if no_command:
        try:
            Snmp.disable()
        except:
            raise error.ActionError('Cannot disable SNMP service')
    else:
        try:
            Snmp.enable()
        except:
            raise error.ActionError('Cannot enable SNMP service')


command.add_action('implement-enable-snmp', enable_snmp,
                    {'kwargs': {
                                 'no_command' : '$is-no-command',
                                 'data'       : '$data',
                               } } )


# Add or remove the given line from the config file
def config_line(no_cmd, li, key=None):
    try:
        with cfgfile.FileLock(Snmp.CFG_PATH) as f:
            lines = cfgfile.get_line_list_from_file(f)

            if no_cmd:
                # Remove matching line, if present
                if li in lines:
                    lines.remove(li)
                    cfgfile.put_line_list_to_file(f, lines)
            else:
                # Add matching line, if not present
                if key is None:
                    if li not in lines:
                        lines.append(li)
                        cfgfile.put_line_list_to_file(f, lines)
                else:
                    newcfg = [line for line in lines 
                              if not key in line]
                    newcfg.append(li)
                    cfgfile.put_line_list_to_file(f, newcfg)
    except:
        raise error.ActionError('Cannot access SNMP configuration')


# Add or remove a trap/inform destination
def trap_dest(no_cmd, ip_addr, traptype, community, port):
    # Compose config file line for trap/inform dest,
    # and add it or remove it from the config file
    config_line(no_cmd,
                "%s %s:%s %s\n" % ('trap2sink' if traptype == 'traps' \
                                       else 'informsink',
                                   ip_addr, str(port), community))

# Add or remove a community
def community(no_cmd, community, access):
    # Compose config file line for community,
    # and add it or remove it from the config file
    config_line(no_cmd, "%scommunity %s\n" % (access, community))


Mon_Ops = {
    oidstr.CPU_LOAD            : '>',
    oidstr.MEM_TOTAL_FREE      : '<',
    oidstr.FLOW_TABLE_L2_UTILIZATION      : '>',
    oidstr.FLOW_TABLE_TCAM_FM_UTILIZATION : '>',
    oidstr.LINK_TABLE_UTILIZATION         : '>'
}

# Handle trap threshold [interval]
def trap_generic_cmd(no_cmd, data):
    trap = data['trap']
    threshold = data['threshold']
    
    monitor_cmd = "monitor" + \
                    (" -r %d" % data['interval'] if 'interval' in data else "")
        
    trapdict = BSN_SL_SENSOR_OID_TABLE.get(trap)
    if trapdict is None:
        raise error.ActionError("Trap %s unsupported on %s", trap, Platform.platform())

    items = trapdict.items()
    for item in items:
        cmd_id = "%s_%s_" % (trap, 'threshold')
        config_line(no_cmd, "%s -I %s%s %s %s %d\n" %
                    (monitor_cmd, cmd_id, str(threshold), 
                     item[1], Mon_Ops[trap], threshold), 
                     key=cmd_id)


BSN_SL_SENSOR_NAME_TO_OID_INDEX_TABLE = {
    oidstr.THERMAL_CMD : {
        oidstr.NAME_TO_INDEX_MAP : {
            'all' : '',
            # index to be added
            },
        },
                
    oidstr.FAN_CMD : {
        oidstr.NAME_TO_INDEX_MAP : {
            'all' : '',
            # index to be added
            },   
        },
            
    oidstr.PSU_CMD : {
        oidstr.NAME_TO_INDEX_MAP : {
            'all' : '',
            # index to be added
            },
        },
    }


# Line format
# TYPE: Thermal, Fan, PSU
# <type>,<Type> <name>,<index> 
# Function reads lines of PF_CONFIG_OID_FILE and inserts
# sensors <name, index> into the dictionary above
def trap_pf_oid_file_process(file):
    with open(file) as f:
        for line in f:
            (typ, Type_name, idx) = line.strip('\n').split(',')
            (Typ, name) = Type_name.split(' ')
            try:
                name2map = BSN_SL_SENSOR_NAME_TO_OID_INDEX_TABLE[Typ][oidstr.NAME_TO_INDEX_MAP]      
                name2map[name] = '.' + idx
            except:
                continue

trap_pf_oid_file_process(PF_CONFIG_OID_FILE)
          

def trap_sensor_name_tuple_get(trap):
    try:    
        name2index = BSN_SL_SENSOR_NAME_TO_OID_INDEX_TABLE \
                        [trap][oidstr.NAME_TO_INDEX_MAP]
        return tuple(name2index.keys())
    except:
        return ()
    
def trap_name_to_oid_index(trap, name):
    try:
        index = BSN_SL_SENSOR_NAME_TO_OID_INDEX_TABLE \
                    [trap][oidstr.NAME_TO_INDEX_MAP][name]
        return index
    except:
        raise error.ActionError("Trap %s name %s unsupported on %s", 
                                trap, name, Platform.platform())

# Handle trap name threshold|status [interval]
def trap_sensor_cmd(no_cmd, data):
    cmd_id = None
    monitor_name = None
    operator = None
    trap  = data['trap']
    sensor_name = data['name']
    threshold_or_status_value = None

    monitor_cmd = "monitor" + \
                    (" -r %d" % data['interval'] if 'interval' in data else "")

    sl_trapdict = BSN_SL_SENSOR_OID_TABLE.get(trap)
    if sl_trapdict is None:
        raise error.ActionError("Trap command %s unsupported", trap)
    
    info_key = data['info_key']
    
    # Get value for status or threshold
    if oidstr.STATUS in data:
        value_name = data[oidstr.STATUS]
        cmd_id = "%s_%s_%s_%s" % (trap, sensor_name, info_key, value_name)
        monitor_name = cmd_id
        # Get integer value from status enums: missing, good, failed
        threshold_or_status_value = sl_trapdict.get(value_name)
        operator = '=='
    else:
        (ops_name, ops) = data['operator']
        threshold_or_status_value = data[oidstr.VALUE]
        cmd_id = "%s_%s_%s_%s_" % (trap, sensor_name, info_key, ops_name)
        monitor_name = "%s%s" % (cmd_id, str(threshold_or_status_value))
        operator = ops

    # Get sensor info_oid : <sensor>.<info>
    info_oid = sl_trapdict.get(info_key)
    if info_oid is None:
        raise error.ActionError("Trap %s info %s unsupported on %s",
                                 trap, info_key, Platform.platform())

    # Sensor index is platform dependent
    sensor_index = trap_name_to_oid_index(trap, sensor_name)
    
    # Final oid for the monitor command
    # <info_oid>.<index>
    oid = info_oid + sensor_index
    config_line(no_cmd, "%s -I %s %s %s %d\n" % 
                (monitor_cmd, monitor_name, oid, 
                 operator, threshold_or_status_value),
                key=cmd_id)


def config_snmp(no_command, data, is_init):
    if 'host' in data:
        trap_dest(no_command,
                  data['host'],
                  data['notification'],
                  data['community'],
                  data['port']
                  )

    elif 'trap' in data:
        if data['trap'] == LINK_UP_DOWN_CLI:
            config_line(no_command, LINK_UP_NOTIFICATION)
            config_line(no_command, LINK_DOWN_NOTIFICATION)
            config_line(no_command, LINK_UP_MONITOR % data['interval'],
                        key=LINK_UP_MONITOR_CMD_ID)
            config_line(no_command, LINK_DOWN_MONITOR % data['interval'],
                        key=LINK_DOWN_MONITOR_CMD_ID)
        elif data['trap'] == AUTH_FAIL_CLI:
            config_line(no_command, AUTH_FAIL_NOTIFICATION)
        elif data['trap'] == oidstr.THERMAL_CMD or \
            data['trap'] == oidstr.FAN_CMD or \
            data['trap'] == oidstr.PSU_CMD:
            trap_sensor_cmd(no_command, data)
        else:
            trap_generic_cmd(no_command, data)

    elif 'access' in data:
        community(no_command, data['community'], data['access'])

    else:
        try:
            with cfgfile.FileLock(Snmp.CFG_PATH) as f:
                lines = cfgfile.get_line_list_from_file(f)
                cfg = parse_snmpd_conf(lines)

                for key in datakeywords:
                    if key in data:
                        if no_command:
                            if (key in cfg and
                                (data[key] == '' or data[key] == cfg[key][0])):
                                del lines[cfg[key][1]]
                        else:
                            val = data[key]
                            newline = '%s %s\n' % \
                                (snmpkeywords[datakeywords.index(key)], val)
                            if key in cfg:
                                lines[cfg[key][1]] = newline
                            else:
                                lines.append(newline)

                cfgfile.put_line_list_to_file(f, lines)
        except:
            raise error.ActionError('Cannot access SNMP configuration')

    if get_snmp_status() == 'enabled':
        Snmp.restart(deferred=is_init)
        

command.add_action('implement-config-snmp', config_snmp,
                    {'kwargs': {
                                 'no_command' : '$is-no-command',
                                 'data'       : '$data',
                                 'is_init'    : '$is-init',
                               } } )

SNMP_SERVER_COMMAND_DESCRIPTION = {
    'name'         : 'snmp-server',
    'mode'         : 'config',
    'short-help'   : 'Configure the SNMP server',
    'action'       : 'implement-config-snmp',
    'no-action'    : 'implement-config-snmp',
    'doc'          : 'snmp|snmp-server',
    'doc-example'  : 'snmp|snmp-server-example',
    'args'         : (
        {
            'choices': (
                (
                    {
                        'token'      : 'enable',
                        'short-help' : 'Enable SNMP',
                        'doc'        : 'snmp|snmp-server-enable',
                        'action'     : 'implement-enable-snmp',
                        'no-action'  : 'implement-enable-snmp',
                    },
                ),
                (
                    {
                        'token'           : 'community',
                        'short-help'      : 'Set community string and access privs',
                        'doc'             : 'snmp|snmp-server-community',
                    },
                    {
                        'field'           : 'access',
                        'short-help'      : 'Type of access with this community string',
                        'type'            : 'enum',
                        'values'          : ('rw', 'ro'),
                        'doc'             : 'snmp|+',
                    },
                    {
                        'field'           : 'community',
                        'type'            : 'string',
                        'syntax-help'     : 'Value for the SNMP community string',
                    },
                ),
                (
                    {
                        'token'           : 'location',
                        'short-help'      : 'Text for mib object sysLocation',
                        'doc'             : 'snmp|snmp-server-location',
                        'data'            : { 'location' : '' },
                    },
                    {
                        'field'           : 'location',
                        'type'            : 'string',
                        'optional-for-no' : True,
                        'syntax-help'     : 'Value for the SNMP location string',
                    },
                ),
                (
                    {
                        'token'           : 'contact',
                        'short-help'      : 'Text for mib object sysContact',
                        'doc'             : 'snmp|snmp-server-contact',
                        'data'            : { 'contact' : '' },
                    },
                    {
                        'field'           : 'contact',
                        'type'            : 'string',
                        'optional-for-no' : True,
                        'syntax-help'     : 'Value for the SNMP contact string',
                    },
                ),
                (
                    {
                        'token'           : 'host',
                        'short-help'      : 'Host to receive traps or informs',
                        'doc'             : 'snmp|snmp-server-host',
                    },
                    {
                        'field'           : 'host',
                        'type'            : 'ip-address-or-domain-name',
                    },
                    {
                        'field'           : 'notification',
                        'short-help'      : 'Type of notification',
                        'type'            : 'enum',
                        'values'          : ('traps', 'informs'),
                        'doc'             : 'snmp|+',
                    },
                    {
                        'field'           : 'community',
                        'base-type'       : 'identifier',  # FIXME change type, with 'reserved' field
                        'syntax-help'     : 'SNMP community string for notification',
                        'reserved'        : [ 'udp-port' ],
                    },
                    {
                        'token'           : 'udp-port',
                        'syntax-help'     : 'UDP port for notification',
                        'doc'             : 'snmp|snmp-server-udp-port',
                    },
                    {
                        'field'           : 'port',
                        'type'            : 'port',
                        'syntax-help'     : 'UDP port for notification',
                    },
                ),
                (
                    {
                        'field'           : 'trap',
                        'tag'             : 'trap',
                        'short-help'      : 'Trap type',
                        'type'            : 'enum',
                        'values'          : (oidstr.CPU_LOAD,
                                             oidstr.MEM_TOTAL_FREE,
                                             oidstr.FLOW_TABLE_L2_UTILIZATION,
                                             oidstr.FLOW_TABLE_TCAM_FM_UTILIZATION),
                        'doc'             : 'snmp|+',
                    },
                    {
                        'field'           : 'threshold',
                        'tag'             : 'threshold',
                        'short-help'      : 'Threshold value',
                        'base-type'       : 'integer',
                        'doc'             : 'snmp|snmp-threshold',
                    },
                    {
                        'field'           : 'interval',
                        'tag'             : 'interval',
                        'short-help'      : 'Polling interval in seconds',
                        'optional'        : True,
                        'optional-for-no' : True,
                        'base-type'       : 'integer',
                        # minimum is 10s
                        'range'           : (10,100000)
                    },
                ),
                (
                    {
                        'token'           : 'trap',
                        'short-help'      : 'Enable trap',
                    },
                    {
                        'token'           : LINK_UP_DOWN_CLI,
                        'short-help'      : 'Link up/down notification',
                        'data'            : { 'trap' : LINK_UP_DOWN_CLI },
                        'doc'             : 'snmp|snmp-linkUpDown',
                    },
                    {
                        'field'           : 'interval',
                        'tag'             : 'interval',
                        'short-help'      : 'Polling interval in seconds',
                        'base-type'       : 'integer',
                    },
                ),
                (
                    {
                        'token'           : 'trap',
                        'short-help'      : 'Enable trap',
                    },
                    {
                        'token'           : oidstr.THERMAL_CMD,
                        'short-help'      : 'Thermal sensors',
                        'data'            : { 'trap' : oidstr.THERMAL_CMD },
                        'doc'             : 'snmp|snmp-sensor-thermal',
                    },
                    {
                        'field'           : 'name',
                        'short-help'      : 'Thermal sensor name; see "show environment"',
                        'type'            : 'enum',
                        'values'          : trap_sensor_name_tuple_get(oidstr.THERMAL_CMD),
                        'doc'             : 'snmp|+',
                    },
                    {
                    'choices': (
                        (
                            {
                                'token'           : oidstr.THERMAL_TEMP,
                                'short-help'      : 'Trap on temperature',
                                'data'            : { 'info_key'  : oidstr.THERMAL_TEMP },
                            },
                            {
                                'token'           : 'max',
                                'data'            : {'operator' : ('max', '>')},
                                'short-help'      : 'Trap if temperature rises above this value, in milliCelsius',
                            },
                            {
                                'field'           : oidstr.VALUE,
                                'base-type'       : 'integer',
                                'range'           : trap_sensor_range_get
                                                    (oidstr.THERMAL_CMD, oidstr.THERMAL_TEMP)
                            }
                        ),
                        (
                            {
                                'field'           : oidstr.THERMAL_STATUS,
                                'tag'             : oidstr.THERMAL_STATUS,
                                'data'            : {'info_key' : oidstr.THERMAL_STATUS },
                                'short-help'      : 'Trap if status changes to this value',
                                'type'            : 'enum',
                                'values'          : (oidstr.STATUS_GOOD, 
                                                     oidstr.STATUS_FAILED,
                                                     oidstr.STATUS_MISSING)
                            }
                        )
                    )
                    }, # ending of thermal choices
                    {
                        'field'           : 'interval',
                        'tag'             : 'interval',
                        'short-help'      : 'Polling interval in seconds',
                        'optional'        : True,
                        'optional-for-no' : True,
                        'base-type'       : 'integer',
                        # minimum is 10s
                        'range'           : (10,100000)
                    },
                ),
                (
                    {
                        'token'           : 'trap',
                        'short-help'      : 'Enable trap',
                    },
                    {
                        'token'           : oidstr.FAN_CMD,
                        'short-help'      : 'Fan sensors',
                        'data'            : { 'trap' : oidstr.FAN_CMD },
                        'doc'             : 'snmp|snmp-sensor-fan',
                    },
                    {
                        'field'           : 'name',
                        'short-help'      : 'Fan sensor name; see "show environment"',
                        'type'            : 'enum',
                        'values'          : trap_sensor_name_tuple_get(oidstr.FAN_CMD),
                        'doc'             : 'snmp|+',
                    },
                    {
                    'choices': (
                        (
                            {
                                'field'           : oidstr.FAN_STATUS,
                                'tag'             : oidstr.FAN_STATUS,
                                'data'            : { 'info_key'  : oidstr.FAN_STATUS },
                                'short-help'      : 'Trap if status changes to this value',
                                'type'            : 'enum',
                                'values'          : (oidstr.STATUS_GOOD, 
                                                     oidstr.STATUS_FAILED,
                                                     oidstr.STATUS_MISSING)
                            }
                        ),
                        (
                            {
                                'token'           : oidstr.FAN_RPM,
                                'short-help'      : 'Trap on fan speed rotation per minute',
                                'data'            : { 'info_key' : oidstr.FAN_RPM },
                            },
                            {
                                'token'           : 'min',
                                'data'            : {'operator' : ('min', '<')},
                                'short-help'      : 'Trap if fan speed falls below this value, in rotation per minute',
                            },
                            {
                                'field'           : oidstr.VALUE,
                                'base-type'       : 'integer',
                                'range'           : trap_sensor_range_get
                                                    (oidstr.FAN_CMD, oidstr.FAN_RPM)
                            }
                        ),
                        (
                            {
                                'token'           : oidstr.FAN_PERCENTAGE,
                                'short-help'      : 'Trap on fan speed percentage',
                                'data'            : { 'info_key' : oidstr.FAN_PERCENTAGE },
                            },
                            {
                                'token'           : 'min',
                                'data'            : {'operator' : ('min', '<')},
                                'short-help'      : 'Trap if fan speed falls below this value, in percent',
                            },
                            {
                                'field'           : oidstr.VALUE,
                                'base-type'       : 'integer',
                                'range'           : trap_sensor_range_get
                                                    (oidstr.FAN_CMD, oidstr.FAN_PERCENTAGE)
                            }
                        ),
                        
                    )
                    }, # ending of fan choices
                    {
                        'field'           : 'interval',
                        'tag'             : 'interval',
                        'short-help'      : 'Polling interval in seconds',
                        'optional'        : True,
                        'optional-for-no' : True,
                        'base-type'       : 'integer',
                        # minimum is 10s
                        'range'           : (10,100000)
                    },
                ),
                (
                    {
                        'token'           : 'trap',
                        'short-help'      : 'Enable trap',
                    },
                    {
                        'token'           : oidstr.PSU_CMD,
                        'short-help'      : 'PSU sensors',
                        'data'            : { 'trap' : oidstr.PSU_CMD },
                        'doc'             : 'snmp|snmp-sensor-psu',
                    },
                    {
                        'field'           : 'name',
                        'short-help'      : 'PSU sensor name; see "show environment"',
                        'type'            : 'enum',
                        'values'          : trap_sensor_name_tuple_get(oidstr.PSU_CMD),
                        'doc'             : 'snmp|+',
                    },
                    {
                    'choices': (
                        (
                            {
                                'field'           : oidstr.PSU_STATUS,
                                'tag'             : oidstr.PSU_STATUS,
                                'data'            : { 'info_key'  : oidstr.PSU_STATUS },
                                'short-help'      : 'Trap if status changes to this value',
                                'type'            : 'enum',
                                'values'          : (oidstr.STATUS_GOOD, 
                                                     oidstr.STATUS_FAILED,
                                                     oidstr.STATUS_MISSING)
                            }
                        ),
                        (
                            {
                                'token'           : oidstr.PSU_VIN,
                                'short-help'      : 'Trap on input voltage',
                                'data'            : { 'info_key' : oidstr.PSU_VIN },
                            },
                            {
                                'token'           : 'max',
                                'data'            : {'operator' : ('max', '>')},
                                'short-help'      : 'Trap if input voltage rises above this value, in millivolts',
                            },
                            {
                                'field'           : oidstr.VALUE,
                                'base-type'       : 'integer',
                                'range'           : trap_sensor_range_get
                                                    (oidstr.PSU_CMD,oidstr.PSU_VIN)
                            }
                        ),
                        (
                            {
                                'token'           : oidstr.PSU_VOUT,
                                'short-help'      : 'Trap on output voltage',
                                'data'            : { 'info_key' : oidstr.PSU_VOUT },
                            },
                            {
                                'token'           : 'max',
                                'data'            : {'operator' : ('max', '>')},
                                'short-help'      : 'Trap if output voltage rises above this value, in millivolts',
                            },
                            {
                                'field'           : oidstr.VALUE,
                                'base-type'       : 'integer',
                                'range'           : trap_sensor_range_get
                                                    (oidstr.PSU_CMD, oidstr.PSU_VOUT)
                            }
                        ),
                        (
                            {
                                'token'           : oidstr.PSU_IIN,
                                'short-help'      : 'Trap on input current',
                                'data'            : { 'info_key' : oidstr.PSU_IIN },
                            },
                            {
                                'token'           : 'max',
                                'data'            : {'operator' : ('max', '>')},
                                'short-help'      : 'Trap if input current rises above this value, in milliamperes',
                            },
                            {
                                'field'           : oidstr.VALUE,
                                'base-type'       : 'integer',
                                'range'           : trap_sensor_range_get
                                                    (oidstr.PSU_CMD, oidstr.PSU_IIN)
                            }
                        ),
                        (
                            {
                                'token'           : oidstr.PSU_IOUT,
                                'short-help'      : 'Trap on output current',
                                'data'            : { 'info_key' : oidstr.PSU_IOUT },
                            },
                            {
                                'token'           : 'max',
                                'data'            : {'operator' : ('max', '>')},
                                'short-help'      : 'Trap if output current rises above this value, in milliamperes',
                            },
                            {
                                'field'           : oidstr.VALUE,
                                'base-type'       : 'integer',
                                'range'           : trap_sensor_range_get
                                                    (oidstr.PSU_CMD, oidstr.PSU_IOUT)
                            }
                        ),
                        (
                            {
                                'token'           : oidstr.PSU_PIN,
                                'short-help'      : 'Trap on input power',
                                'data'            : { 'info_key' : oidstr.PSU_PIN },
                            },
                            {
                                'token'           : 'max',
                                'data'            : {'operator' : ('max', '>')},
                                'short-help'      : 'Trap if input power rises above this value, in milliwatts',
                            },
                            {
                                'field'           : oidstr.VALUE,
                                'base-type'       : 'integer',
                                'range'           : trap_sensor_range_get
                                                    (oidstr.PSU_CMD, oidstr.PSU_PIN)
                            }
                        ),
                        (
                            {
                                'token'           : oidstr.PSU_POUT,
                                'short-help'      : 'Trap on output power',
                                'data'            : { 'info_key' : oidstr.PSU_POUT },
                            },
                            {
                                'token'           : 'max',
                                'data'            : {'operator' : ('max', '>')},
                                'short-help'      : 'Trap if output power rises above this value, in milliwatts',
                            },
                            {
                                'field'           : oidstr.VALUE,
                                'base-type'       : 'integer',
                                'range'           : trap_sensor_range_get
                                                    (oidstr.PSU_CMD, oidstr.PSU_POUT)
                            }
                        ),
                    )
                    }, # ending of psu choices
                    {
                        'field'           : 'interval',
                        'tag'             : 'interval',
                        'short-help'      : 'Polling interval in seconds',
                        'optional'        : True,
                        'optional-for-no' : True,
                        'base-type'       : 'integer',
                        # minimum is 10s
                        'range'           : (10,100000)
                    },
                ),
                (
                    {
                        'token'           : 'trap',
                        'short-help'      : 'Enable trap',
                    },
                    {
                        'token'           : AUTH_FAIL_CLI,
                        'short-help'      : 'Authentication failure notification',
                        'data'            : { 'trap' : AUTH_FAIL_CLI },
                        'doc'             : 'snmp|snmp-authFail',
                    },
                ),
            ), # snmp choices: enable, host, location, trap
        },
    ),
}


def running_config_snmp(context, runcfg, words):
    comp_runcfg = []

    try:
        with cfgfile.FileLock(Snmp.CFG_PATH) as f:
            lines = cfgfile.get_line_list_from_file(f)
    except:
        raise error.ActionError('Cannot access SNMP configuration')
    cfg = parse_snmpd_conf(lines)

    # collect component-specific config
    if get_snmp_status() == 'enabled':
        comp_runcfg.append('snmp-server enable\n')
    if 'location' in cfg:
        comp_runcfg.append('snmp-server location %s\n' %
                           utif.quote_string(cfg['location'][0]))
    if 'contact' in cfg:
        comp_runcfg.append('snmp-server contact %s\n' %
                           utif.quote_string(cfg['contact'][0]))

    for li in lines:
        w = li[0:-1].split(' ')
        if w[0] == 'rocommunity' or w[0] == 'rwcommunity':
            comp_runcfg.append('snmp-server community %s %s\n' %
                               (w[0][0:2], w[1])
                               )
            continue
        if w[0] == 'trap2sink':
            ww = w[1].split(':')
            comp_runcfg.append('snmp-server host %s traps %s udp-port %s\n' %
                               (ww[0], w[2], ww[1])
                               )
            continue
        if w[0] == 'informsink':
            ww = w[1].split(':')
            comp_runcfg.append('snmp-server host %s informs %s udp-port %s\n' %
                               (ww[0], w[2], ww[1])
                               )
            continue
        if w[0] == 'authtrapenable' and \
                len(w) == AUTH_FAIL_NOTIFICATION_TOKEN_NUM and w[1] == '1':
            comp_runcfg.append('snmp-server trap %s\n' % (AUTH_FAIL_CLI))
            continue
        if w[0] == 'monitor' and len(w) == LINK_UP_MONITOR_TOKEN_NUM:
            # The command linkUpDown results 2 monitor commands
            # and we print only 1 of them
            if w[4] == 'linkUpTrap':
                comp_runcfg.append('snmp-server trap %s interval %s\n' %
                                   (LINK_UP_DOWN_CLI, w[2])
                                  )
            # Skip another
            continue
        if w[0] == 'monitor':
            if w[1] == '-r':
                trap_cmd = w[4].replace("_", " ")
                comp_runcfg.append('snmp-server trap %s interval %s\n' % 
                                   (trap_cmd, w[2]))
            else:
                trap_cmd = w[2].replace("_", " ")
                comp_runcfg.append('snmp-server trap %s\n' % trap_cmd)
            continue
    # attach component-specific config
    if len(comp_runcfg) > 0:
        runcfg.append('!\n')
        runcfg += comp_runcfg

snmp_running_config_tuple = (
    (
        {
            'optional'   : False,
            'field'      : 'running-config',
            'type'       : 'enum',
            'values'     : 'snmp-server',
            'short-help' : 'Configuration for SNMP',
            'doc'        : 'running-config|show-snmp',
        },
    ),
)

run_config.register_running_config('snmp-server', 3000,  None,
                                   running_config_snmp,
                                   snmp_running_config_tuple)

