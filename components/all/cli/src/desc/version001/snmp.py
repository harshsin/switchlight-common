# Copyright (c) 2013-2014 BigSwitch Networks

from collections import namedtuple
import command
import run_config
import subprocess
from sl_util import Service, utils, const, conf_state
import utif
import cfgfile
import error
from switchlight.platform.base import *
from switchlight.platform.current import SwitchLightPlatform

Platform=SwitchLightPlatform()

LINK_UP_DOWN_CLI              = 'linkUpDown'
#Used to be: LINK_UP_DOWN_NOTIFICATION_CMD = 'linkUpDownNotifications'
#Now using other cmds to allow polling interval setting. See 'man snmpd.conf'
trapLinkUp    = '.1.3.6.1.6.3.1.1.5.4'
trapLinkDown  = '.1.3.6.1.6.3.1.1.5.3'
ifIndex       = '.1.3.6.1.2.1.2.2.1.1'
ifAdminStatus = '.1.3.6.1.2.1.2.2.1.7'
ifOperStatus  = '.1.3.6.1.2.1.2.2.1.8'
LINK_UP_NOTIFICATION   = 'notificationEvent linkUpTrap %s %s %s %s\n' % \
    (trapLinkUp, ifIndex, ifAdminStatus, ifOperStatus)
LINK_DOWN_NOTIFICATION = 'notificationEvent linkDownTrap %s %s %s %s\n' % \
    (trapLinkDown, ifIndex, ifAdminStatus, ifOperStatus)
LINK_UP_MONITOR   = 'monitor -r %%d -e linkUpTrap "Generate linkUp" %s != 2\n' % ifOperStatus
LINK_UP_MONITOR_CMD_ID = "Generate linkUp"
LINK_UP_MONITOR_TOKEN_NUM = len(LINK_UP_MONITOR.split(' '))
LINK_DOWN_MONITOR = 'monitor -r %%d -e linkDownTrap "Generate linkDown" %s == 2\n' % ifOperStatus
LINK_DOWN_MONITOR_CMD_ID = "Generate linkDown"

AUTH_FAIL_CLI = 'authenticationFailure'
AUTH_FAIL_NOTIFICATION = 'authtrapenable 1\n'
AUTH_FAIL_NOTIFICATION_TOKEN_NUM = len(AUTH_FAIL_NOTIFICATION.split(' '))

# Platform config OIDs file
# generated by ONLdump
PF_CONFIG_OID_FILE = '/lib/platform-config/current/oids'

# Put all OID CLI strings into this class like a summary of what
# we support in CLI instead of going through the long CLI structures.
# These strings are used for CLI and some reverse CLI mapping
class oidstr(object):
    PREFIX='prefix'
    STATUS='status'
    STATUS_GOOD='good'
    STATUS_FAILED='failed'
    STATUS_PRESENT='present'
    STATUS_MISSING='missing'
    STATUS_PLUGGED_IN='plugged_in'
    STATUS_UNPLUGGED='unplugged'
    NAME_TO_INDEX_MAP='name2index'
    THERMAL_CMD='Thermal'
    THERMAL_STATUS=STATUS
    THERMAL_TEMP='temperature'
    FAN_CMD='Fan'
    FAN_STATUS=STATUS
    FAN_RPM='rpm'
    FAN_PERCENTAGE='percentage'
    PSU_CMD='PSU'
    PSU_STATUS=STATUS
    PSU_VIN='Vin'
    PSU_VOUT='Vout'
    PSU_IIN='Iin'
    PSU_IOUT='Iout'
    PSU_PIN='Pin'
    PSU_POUT='Pout'
    CPU_LOAD='cpu-load'
    MEM_TOTAL_FREE='mem-total-free'
    INTERFACES='interfaces'
    FLOW_TABLE_L2_UTILIZATION='flow-table-l2-util'
    FLOW_TABLE_TCAM_FM_UTILIZATION='flow-table-tcam-fm-util'
    LINK_TABLE_UTILIZATION='link-table-util'

#from MIB file
BSN_SL_SENSOR_OID_SENSORS = '.1.3.6.1.4.1.37538.2.3'
BSN_SL_SENSOR_OID_TEMP_IDX = BSN_SL_SENSOR_OID_SENSORS + '.1.1'
BSN_SL_SENSOR_OID_TEMP_IDX_STATUS = '.3'
BSN_SL_SENSOR_OID_TEMP_IDX_VALUE    = '.4'
BSN_SL_SENSOR_OID_FAN_IDX = BSN_SL_SENSOR_OID_SENSORS + '.2.1'
BSN_SL_SENSOR_OID_FAN_IDX_STATUS = '.3'
BSN_SL_SENSOR_OID_FAN_IDX_RPM    = '.5'
BSN_SL_SENSOR_OID_FAN_IDX_PERCENTAGE = '.6'
BSN_SL_SENSOR_OID_PSU_IDX = BSN_SL_SENSOR_OID_SENSORS + '.3.1'
BSN_SL_SENSOR_OID_PSU_IDX_STATUS = '.3'
BSN_SL_SENSOR_OID_PSU_IDX_VIN = '.6'
BSN_SL_SENSOR_OID_PSU_IDX_VOUT = '.7'
BSN_SL_SENSOR_OID_PSU_IDX_IIN = '.8'
BSN_SL_SENSOR_OID_PSU_IDX_IOUT = '.9'
BSN_SL_SENSOR_OID_PSU_IDX_PIN = '.10'
BSN_SL_SENSOR_OID_PSU_IDX_POUT = '.11'

BSN_SL_SENSOR_OID_TABLE = {
    oidstr.THERMAL_CMD : {
        oidstr.PREFIX          : BSN_SL_SENSOR_OID_TEMP_IDX,
        oidstr.THERMAL_STATUS  : BSN_SL_SENSOR_OID_TEMP_IDX + BSN_SL_SENSOR_OID_TEMP_IDX_STATUS,
        oidstr.THERMAL_TEMP    : BSN_SL_SENSOR_OID_TEMP_IDX + BSN_SL_SENSOR_OID_TEMP_IDX_VALUE,
        oidstr.STATUS_GOOD     : '1',
        oidstr.STATUS_FAILED   : '2',
        oidstr.STATUS_MISSING  : '0',
        },

    oidstr.FAN_CMD : {
        oidstr.PREFIX         : BSN_SL_SENSOR_OID_FAN_IDX,
        oidstr.FAN_STATUS     : BSN_SL_SENSOR_OID_FAN_IDX + BSN_SL_SENSOR_OID_FAN_IDX_STATUS,
        oidstr.FAN_RPM        : BSN_SL_SENSOR_OID_FAN_IDX + BSN_SL_SENSOR_OID_FAN_IDX_RPM,
        oidstr.FAN_PERCENTAGE : BSN_SL_SENSOR_OID_FAN_IDX + BSN_SL_SENSOR_OID_FAN_IDX_PERCENTAGE,
        oidstr.STATUS_GOOD    : '1',
        oidstr.STATUS_FAILED  : '2',
        oidstr.STATUS_MISSING : '0',
        },

    oidstr.PSU_CMD : {
        oidstr.PREFIX       : BSN_SL_SENSOR_OID_PSU_IDX,
        oidstr.PSU_STATUS   : BSN_SL_SENSOR_OID_PSU_IDX + BSN_SL_SENSOR_OID_PSU_IDX_STATUS,
        oidstr.PSU_VIN      : BSN_SL_SENSOR_OID_PSU_IDX + BSN_SL_SENSOR_OID_PSU_IDX_VIN,
        oidstr.PSU_VOUT     : BSN_SL_SENSOR_OID_PSU_IDX + BSN_SL_SENSOR_OID_PSU_IDX_VOUT,
        oidstr.PSU_IIN      : BSN_SL_SENSOR_OID_PSU_IDX + BSN_SL_SENSOR_OID_PSU_IDX_IIN,
        oidstr.PSU_IOUT     : BSN_SL_SENSOR_OID_PSU_IDX + BSN_SL_SENSOR_OID_PSU_IDX_IOUT,
        oidstr.PSU_PIN      : BSN_SL_SENSOR_OID_PSU_IDX + BSN_SL_SENSOR_OID_PSU_IDX_PIN,
        oidstr.PSU_POUT     : BSN_SL_SENSOR_OID_PSU_IDX + BSN_SL_SENSOR_OID_PSU_IDX_POUT,
        oidstr.STATUS_GOOD    : '1',
        oidstr.STATUS_FAILED  : '2',
        oidstr.STATUS_MISSING : '0',
        },

    oidstr.CPU_LOAD : {
        'cpuload'        : '.1.3.6.1.4.1.2021.10.1.5.1',
        },

    oidstr.MEM_TOTAL_FREE : {
        'memtotalfree'   : '.1.3.6.1.4.1.2021.4.11.0',
        },

    oidstr.INTERFACES: {
        'interfaces'     : '.1.3.6.1.2.1.2',
        },

    oidstr.FLOW_TABLE_L2_UTILIZATION : {
        'ft_l2_utilization'    : '.1.3.6.1.4.1.37538.2.1.1.3',
        },

    oidstr.FLOW_TABLE_TCAM_FM_UTILIZATION : {
        'ft_tcam_fm_utilization'    : '.1.3.6.1.4.1.37538.2.1.2.3',
        },

    oidstr.LINK_TABLE_UTILIZATION : {
        'ft_link_utilization'    : '.1.3.6.1.4.1.37538.2.2.1.3',
        },
    }

BSN_SL_SENSOR_TRAP_OPS = {
        'equal' : '==',
        'max'   : '>',
        'min'   : '<'
    }
def trap_sensor_op_get(op_name):
    return (op_name, BSN_SL_SENSOR_TRAP_OPS[op_name])

# We can put the range in here
# In the future we can read info from ONLdump
# This is a subject to change
BSN_SL_SENSOR_RANGE_TABLE = {
    oidstr.THERMAL_CMD : {
        oidstr.THERMAL_TEMP    : (0, 300000)
        },

    oidstr.FAN_CMD : {
        oidstr.FAN_RPM        : (0, 100000),
        oidstr.FAN_PERCENTAGE : (0, 100)
        },

    oidstr.PSU_CMD : {
        oidstr.PSU_VIN      : (0, 240000),
        oidstr.PSU_VOUT     : (0, 240000),
        oidstr.PSU_IIN      : (0, 10000),
        oidstr.PSU_IOUT     : (0, 10000),
        oidstr.PSU_PIN      : (0, 1000000),
        oidstr.PSU_POUT     : (0, 1000000),
        },
    }

def trap_sensor_range_get(sensor_cmd, sensor_info):
    return BSN_SL_SENSOR_RANGE_TABLE[sensor_cmd][sensor_info]

class Snmp(Service):
    SVC_NAME = "snmpd"
    CFG_PATH = const.SNMP_CFG_PATH

conf_state.register_save("snmp", Snmp.save_default_settings)
conf_state.register_revert("snmp", Snmp.revert_default_settings)

def get_snmp_status():
    st = Snmp.status()
    if st == Service.HALTED:
        status = 'disabled'
    elif st == Service.RUNNING:
        status = 'enabled'
    else:
        status = "ERROR"
    return status

# datakeywords to parse CLI data dict parameter.
# snmpkeywords to parse snmpd.conf.
# datakeywords and snmpkeywords must be in 1-to-1 correspondance
#   e.g. value of data['location'] is value of 'sysLocation' in snmpd.conf
datakeywords = ['contact', 'location']
snmpkeywords = ['sysContact', 'sysLocation']

def parse_snmpd_conf(lines):
    """
    Return a dict whose keys are those in "datakeywords" above,
    and whose values are (associated value, index in "lines") tuples.
    """
    dt = {}
    for (idx, line) in enumerate(lines):
        tokens = line.split(None, 1)
        if len(tokens) == 2 and tokens[0] in snmpkeywords:
            # WARNING no handling of other rocommunity/rwcommunity params
            val = tokens[1].strip()
            dt[datakeywords[snmpkeywords.index(tokens[0])]] = (val, idx)
    return dt


def show_snmp_server(data):
    try:
        with cfgfile.FileLock(Snmp.CFG_PATH) as f:
            lines = cfgfile.get_line_list_from_file(f)
    except:
        raise error.ActionError('Cannot access SNMP configuration')

    cfg = parse_snmpd_conf(lines)

    print "status:  %s" % get_snmp_status()
    print "configuration:"
    for key in datakeywords:
        if key in cfg:
            print '  %-12s  %s' % (key, cfg[key][0])
    print '  communities:'
    for  li in lines:
        w = li[:-1].split(' ')
        if w[0] in ('rocommunity', 'rwcommunity'):
            print '    %s %s' % (w[1], w[0][:2])
    print '  trap/inform destinations:'
    for li in lines:
        w = li[:-1].split(' ')
        if w[0] == 'trap2sink':
            ww = w[1].split(':')
            print '    host %s traps %s udp-port %s' % (ww[0], w[2], ww[1])
            continue
        if w[0] == 'informsink':
            ww = w[1].split(':')
            print '    host %s informs %s udp-port %s' % (ww[0], w[2], ww[1])
            continue
    print '  traps:'
    for li in lines:
        w = li[:-1].split(' ')
        if w[0] == 'authtrapenable' and \
                len(w) == AUTH_FAIL_NOTIFICATION_TOKEN_NUM and w[1] == '1':
            print '    authentification failure'
            continue
        if w[0] == 'monitor' and len(w) == LINK_UP_MONITOR_TOKEN_NUM:
            # The command linkUpDown results 2 monitor commands
            # and we print only 1 of them
            if w[4] == 'linkUpTrap':
                print '    %s, interval %s' % (LINK_UP_DOWN_CLI, w[2])
            continue
        if w[0] == 'monitor':
            if w[1] == '-r':
                trap_cmd = w[4].replace("_", " ")
                print '    %s, interval %s' % (trap_cmd, w[2])
            else:
                trap_cmd = w[2].replace("_", " ")
                print '    %s' % (trap_cmd)
            continue


command.add_action('implement-show-snmp-server', show_snmp_server,
                    {'kwargs': {'data'      : '$data',}})

SHOW_SNMP_SERVER_COMMAND_DESCRIPTION = {
    'name'         : 'show',
    'mode'         : 'login',
    'action'       : 'implement-show-snmp-server',
    'no-supported' : False,
    'args'         : (
        {
            'token'       : 'snmp-server',
            'short-help'  : 'Show the current SNMP server configuration',
            'doc'         : 'snmp|show',
        },
    )
}


def enable_snmp(no_command, data):
    if no_command:
        try:
            Snmp.disable()
        except:
            raise error.ActionError('Cannot disable SNMP service')
    else:
        try:
            Snmp.enable()
        except:
            raise error.ActionError('Cannot enable SNMP service')


command.add_action('implement-enable-snmp', enable_snmp,
                    {'kwargs': {
                                 'no_command' : '$is-no-command',
                                 'data'       : '$data',
                               } } )


# Add or remove the given line from the config file
def config_line(no_cmd, li, key=None):
    try:
        with cfgfile.FileLock(Snmp.CFG_PATH) as f:
            lines = cfgfile.get_line_list_from_file(f)

            if no_cmd:
                # Remove matching line, if present
                if key is None:
                    if li in lines:
                        lines.remove(li)
                        cfgfile.put_line_list_to_file(f, lines)
                else:
                    newcfg = [line for line in lines
                              if not key in line]
                    cfgfile.put_line_list_to_file(f, newcfg)
            else:
                # Add matching line, if not present
                if key is None:
                    if li not in lines:
                        lines.append(li)
                        cfgfile.put_line_list_to_file(f, lines)
                else:
                    newcfg = [line for line in lines
                              if not key in line]
                    newcfg.append(li)
                    cfgfile.put_line_list_to_file(f, newcfg)
    except:
        raise error.ActionError('Cannot access SNMP configuration')


# Add or remove a trap/inform destination
def trap_dest(no_cmd, ip_addr, traptype, community, port):
    # Compose config file line for trap/inform dest,
    # and add it or remove it from the config file
    config_line(no_cmd,
                "%s %s:%s %s\n" % ('trap2sink' if traptype == 'traps' \
                                       else 'informsink',
                                   ip_addr, str(port), community))

# Add or remove a community
def community(no_cmd, community, access):
    # Compose config file line for community,
    # and add it or remove it from the config file
    config_line(no_cmd, "%scommunity %s\n" % (access, community))


Mon_Ops = {
    oidstr.CPU_LOAD            : '>',
    oidstr.MEM_TOTAL_FREE      : '<',
    oidstr.FLOW_TABLE_L2_UTILIZATION      : '>',
    oidstr.FLOW_TABLE_TCAM_FM_UTILIZATION : '>',
    oidstr.LINK_TABLE_UTILIZATION         : '>'
}

# Handle trap threshold [interval]
def trap_generic_cmd(no_cmd, data):
    trap = data['trap']
    threshold = data['threshold']

    interval_cmd = (" -r %d" % data['interval'] if 'interval' in data else "")

    trapdict = BSN_SL_SENSOR_OID_TABLE.get(trap)
    if trapdict is None:
        raise error.ActionError("Trap %s unsupported on %s", trap, Platform.platform())

    items = trapdict.items()
    for item in items:
        monitor_name = " -I %s_%s_%s" % (trap, 'threshold', str(threshold))

        # For a command: command id doesn't have interval because
        #     command interval overwrites existing interval
        # For a no command: command id might include interval because
        #     command interval doesn't remove non-matched existing interval
        # if there is no interval, the interval_cmd = ""
        cmd_id = interval_cmd + monitor_name if no_cmd else monitor_name

        config_line(no_cmd, "monitor%s%s %s %s %d\n" %
                    (interval_cmd, monitor_name,
                     item[1], Mon_Ops[trap], threshold),
                     key=cmd_id)


BSN_SL_SENSOR_NAME_TO_OID_INDEX_TABLE = {
    oidstr.THERMAL_CMD : {
        oidstr.NAME_TO_INDEX_MAP : {
            'all' : '',
            # index to be added
            },
        },

    oidstr.FAN_CMD : {
        oidstr.NAME_TO_INDEX_MAP : {
            'all' : '',
            # index to be added
            },
        },

    oidstr.PSU_CMD : {
        oidstr.NAME_TO_INDEX_MAP : {
            'all' : '',
            # index to be added
            },
        },
    }


# Line format
# TYPE: Thermal, Fan, PSU
# <type>,<Type> <name>,<index>
# Function reads lines of PF_CONFIG_OID_FILE and inserts
# sensors <name, index> into the dictionary above
def trap_pf_oid_file_process(file):
    with open(file) as f:
        for line in f:
            (typ, Type_name, idx) = line.strip('\n').split(',')
            (Typ, name) = Type_name.split(' ')
            try:
                name2map = BSN_SL_SENSOR_NAME_TO_OID_INDEX_TABLE[Typ][oidstr.NAME_TO_INDEX_MAP]
                name2map[name] = '.' + idx
            except:
                continue

trap_pf_oid_file_process(PF_CONFIG_OID_FILE)


def trap_sensor_name_tuple_get(trap):
    try:
        name2index = BSN_SL_SENSOR_NAME_TO_OID_INDEX_TABLE \
                        [trap][oidstr.NAME_TO_INDEX_MAP]
        return tuple(name2index.keys())
    except:
        return ()

def trap_name_to_oid_index(trap, name):
    try:
        index = BSN_SL_SENSOR_NAME_TO_OID_INDEX_TABLE \
                    [trap][oidstr.NAME_TO_INDEX_MAP][name]
        return index
    except:
        raise error.ActionError("Trap %s name %s unsupported on %s",
                                trap, name, Platform.platform())

# Handler sensor info
# if status, then convert good|failed|missing to values
# if temp|rpm|vin .. then get vvalue
def trap_sensor_info_handler(no_cmd, interval_cmd,
                             data, sl_trapdict, monitor_name, oid):

    operator_value = None

    # Get value for status or threshold
    if oidstr.STATUS in data:
        (ops_name, ops) = trap_sensor_op_get('equal')
        value_name = data[oidstr.STATUS]
        monitor_name_status = "%s_%s" % (monitor_name, value_name)
        # Get value from status enums: missing, good, failed
        operator_value = "%s %s" % (ops, sl_trapdict.get(value_name))
        trap_sensor_info_config_line(no_cmd, interval_cmd,
                                     monitor_name_status, oid, operator_value)
    else:
        if 'min' not in data and 'max' not in data:
            if no_cmd:
                # This will delete all min / max 
                operator_value = ""
                trap_sensor_info_config_line(no_cmd, interval_cmd,
                                             monitor_name, oid, operator_value)
            else:
                # Raise error for now
                # FIXME use default value
                raise error.ActionError('Need at least min or max value')
        else: 
            # At least min or max in data
            for extremum in ('min', 'max'):
                if extremum in data:
                    (ops_name, ops) = trap_sensor_op_get(extremum)
                    value = str(data[extremum])
                    operator_value = "%s %s" % (ops, value)
                    monitor_name_extremum = "%s_%s_%s" % (monitor_name, ops_name, value)
                    trap_sensor_info_config_line(no_cmd, interval_cmd,
                                                 monitor_name_extremum, oid, operator_value)            
            
def trap_sensor_info_config_line(no_cmd, interval_cmd, monitor_name, oid, operator_value):
    # For a command: command id doesn't have interval because
    #     command interval overwrites existing interval
    # For a no command: command id might include interval because
    #     command interval doesn't remove non-matched existing interval
    # if there is no interval, the interval_cmd = ""
    cmd_id = interval_cmd + monitor_name if no_cmd else monitor_name

    config_line(no_cmd, "monitor%s%s %s %s\n" %
                (interval_cmd, monitor_name, oid, operator_value),
                key=cmd_id)

def trap_sensor_name_handler(no_command, interval_command,
                             data, trap, sl_trapdict):

    sensor_name = data['name']
    info_key = data['info_key']
    info_oid = sl_trapdict.get(info_key)
    if info_oid is None:
        raise error.ActionError("Trap %s info %s unsupported on %s"
                        % (trap, info_key, Platform.platform()))

    monitor_name = " -I %s_%s_%s" % (trap, sensor_name, info_key)
    oid = info_oid + trap_name_to_oid_index(trap, sensor_name)

    status = data[oidstr.STATUS] if oidstr.STATUS in data else None
    if status is 'all':
        for status in (oidstr.STATUS_GOOD, oidstr.STATUS_FAILED, oidstr.STATUS_MISSING):
            data[oidstr.STATUS] = status
            trap_sensor_info_handler(no_command, interval_command,
                                     data, sl_trapdict, monitor_name, oid)
        #reset data[oidstr.STATUS] for other codes use it
        data[oidstr.STATUS] = 'all'
    else:
        # handle status good|failed|missing
        # or temp|rpm|vin <value>
        trap_sensor_info_handler(no_command, interval_command,
                                 data, sl_trapdict, monitor_name, oid)

def config_snmp(no_command, data, is_init):
    if 'host' in data:
        trap_dest(no_command,
                  data['host'],
                  data['notification'],
                  data['community'],
                  data['port']
                  )

    elif 'trap' in data:
        if data['trap'] == LINK_UP_DOWN_CLI:
            config_line(no_command, LINK_UP_NOTIFICATION)
            config_line(no_command, LINK_DOWN_NOTIFICATION)
            key = None if no_command else LINK_UP_MONITOR_CMD_ID
            config_line(no_command, LINK_UP_MONITOR % data['interval'],
                        key=key)
            key = None if no_command else LINK_DOWN_MONITOR_CMD_ID
            config_line(no_command, LINK_DOWN_MONITOR % data['interval'],
                        key=key)
        elif data['trap'] == AUTH_FAIL_CLI:
            config_line(no_command, AUTH_FAIL_NOTIFICATION)
        elif data['trap'] == oidstr.THERMAL_CMD or \
            data['trap'] == oidstr.FAN_CMD or \
            data['trap'] == oidstr.PSU_CMD:

            interval_command = (" -r %d" % data['interval'] if 'interval' in data else "")

            trap  = data['trap']
            sl_trapdict = BSN_SL_SENSOR_OID_TABLE.get(trap)
            if sl_trapdict is None:
                raise error.ActionError("Trap command %s unsupported", trap)

            sensor_name = data['name']
            if sensor_name is 'all':
                for name in sorted([name for name in trap_sensor_name_tuple_get(data['trap'])
                                    if not 'all' in name]):
                    data['name'] = name
                    trap_sensor_name_handler(no_command, interval_command,
                                             data, trap, sl_trapdict)
                #reset data['name'] for other codes use it
                data['name'] = 'all'
            else:
                trap_sensor_name_handler(no_command, interval_command,
                                         data, trap, sl_trapdict)

        else:
            trap_generic_cmd(no_command, data)

    elif 'access' in data:
        community(no_command, data['community'], data['access'])

    else:
        try:
            with cfgfile.FileLock(Snmp.CFG_PATH) as f:
                lines = cfgfile.get_line_list_from_file(f)
                cfg = parse_snmpd_conf(lines)

                for key in datakeywords:
                    if key in data:
                        if no_command:
                            if (key in cfg and
                                (data[key] == '' or data[key] == cfg[key][0])):
                                del lines[cfg[key][1]]
                        else:
                            val = data[key]
                            newline = '%s %s\n' % \
                                (snmpkeywords[datakeywords.index(key)], val)
                            if key in cfg:
                                lines[cfg[key][1]] = newline
                            else:
                                lines.append(newline)

                cfgfile.put_line_list_to_file(f, lines)
        except:
            raise error.ActionError('Cannot access SNMP configuration')

    if get_snmp_status() == 'enabled':
        Snmp.restart(deferred=is_init)


command.add_action('implement-config-snmp', config_snmp,
                    {'kwargs': {
                                 'no_command' : '$is-no-command',
                                 'data'       : '$data',
                                 'is_init'    : '$is-init',
                               } } )

def sensor_all_status_cli_get(status):
    return (
                {
                    'token'           : status,
                    'short-help'      : 'Trap on status changes',
                },
                {
                    'token'           : 'all',
                    'field'           : status,
                    'data'            : { 'info_key'  : status,
                                          'values'    : 'all' },
                    'short-help'      : 'Trap if any status changes',
                },
            )
def sensor_enum_status_cli_get(status):
    return (
                {
                    'token'           : status,
                    'short-help'      : 'Trap on status changes',
                },
                {
                    'field'           : status,
                    'data'            : { 'info_key'  : status },
                    'short-help'      : 'Trap if status changes to this value',
                    'type'            : 'enum',
                    'values'          : (oidstr.STATUS_GOOD,
                                         oidstr.STATUS_FAILED,
                                         oidstr.STATUS_MISSING)
                }
            )
            
Name_Help = namedtuple('Name_Help', 'name, help')  
def sensor_threshold_cli_extremum_get(cmd, info, extremum):
    return {
                'optional'            : 'True',
                'optional-for-no'     : 'True',
                'args' : (
                    {
                        'token'           : extremum.name,
                        'data'            : {'operator' : trap_sensor_op_get(extremum.name)},
                        'short-help'      : extremum.help,
                    },
                    {
                        'field'           : extremum.name,
                        'base-type'       : 'integer',
                        'range'           : trap_sensor_range_get(cmd, info)
                    },
                ),
            }
def sensor_threshold_cli_get(cmd, info, info_help, min, max):
    return (
                {
                    'token'           : info,
                    'short-help'      : info_help,
                    'data'            : { 'info_key' : info },
                },
                sensor_threshold_cli_extremum_get(cmd, info, min),
                sensor_threshold_cli_extremum_get(cmd, info, max),
            )

SNMP_SERVER_COMMAND_DESCRIPTION = {
    'name'         : 'snmp-server',
    'mode'         : 'config',
    'short-help'   : 'Configure the SNMP server',
    'action'       : 'implement-config-snmp',
    'no-action'    : 'implement-config-snmp',
    'doc'          : 'snmp|snmp-server',
    'doc-example'  : 'snmp|snmp-server-example',
    'args'         : (
        {
            'choices': (
                (
                    {
                        'token'      : 'enable',
                        'short-help' : 'Enable SNMP',
                        'doc'        : 'snmp|snmp-server-enable',
                        'action'     : 'implement-enable-snmp',
                        'no-action'  : 'implement-enable-snmp',
                    },
                ),
                (
                    {
                        'token'           : 'community',
                        'short-help'      : 'Set community string and access privs',
                        'doc'             : 'snmp|snmp-server-community',
                    },
                    {
                        'field'           : 'access',
                        'short-help'      : 'Type of access with this community string',
                        'type'            : 'enum',
                        'values'          : ('rw', 'ro'),
                        'doc'             : 'snmp|+',
                    },
                    {
                        'field'           : 'community',
                        'type'            : 'string',
                        'syntax-help'     : 'Value for the SNMP community string',
                    },
                ),
                (
                    {
                        'token'           : 'location',
                        'short-help'      : 'Text for mib object sysLocation',
                        'doc'             : 'snmp|snmp-server-location',
                        'data'            : { 'location' : '' },
                    },
                    {
                        'field'           : 'location',
                        'type'            : 'string',
                        'optional-for-no' : True,
                        'syntax-help'     : 'Value for the SNMP location string',
                    },
                ),
                (
                    {
                        'token'           : 'contact',
                        'short-help'      : 'Text for mib object sysContact',
                        'doc'             : 'snmp|snmp-server-contact',
                        'data'            : { 'contact' : '' },
                    },
                    {
                        'field'           : 'contact',
                        'type'            : 'string',
                        'optional-for-no' : True,
                        'syntax-help'     : 'Value for the SNMP contact string',
                    },
                ),
                (
                    {
                        'token'           : 'host',
                        'short-help'      : 'Host to receive traps or informs',
                        'doc'             : 'snmp|snmp-server-host',
                    },
                    {
                        'field'           : 'host',
                        'type'            : 'ip-address-or-domain-name',
                    },
                    {
                        'field'           : 'notification',
                        'short-help'      : 'Type of notification',
                        'type'            : 'enum',
                        'values'          : ('traps', 'informs'),
                        'doc'             : 'snmp|+',
                    },
                    {
                        'field'           : 'community',
                        'base-type'       : 'identifier',  # FIXME change type, with 'reserved' field
                        'syntax-help'     : 'SNMP community string for notification',
                        'reserved'        : [ 'udp-port' ],
                    },
                    {
                        'token'           : 'udp-port',
                        'syntax-help'     : 'UDP port for notification',
                        'doc'             : 'snmp|snmp-server-udp-port',
                    },
                    {
                        'field'           : 'port',
                        'type'            : 'port',
                        'syntax-help'     : 'UDP port for notification',
                    },
                ),
                (
                    {
                        'field'           : 'trap',
                        'tag'             : 'trap',
                        'short-help'      : 'Trap type; see "help snmp-server trap" for details',
                        'type'            : 'enum',
                        'values'          : (oidstr.CPU_LOAD,
                                             oidstr.MEM_TOTAL_FREE,
                                             oidstr.FLOW_TABLE_L2_UTILIZATION,
                                             oidstr.FLOW_TABLE_TCAM_FM_UTILIZATION),
                        'doc'             : 'snmp|+',
                    },
                    {
                        'field'           : 'threshold',
                        'tag'             : 'threshold',
                        'short-help'      : 'Threshold value; see "help snmp-server trap" for details',
                        'base-type'       : 'integer',
                        'doc'             : 'snmp|snmp-threshold',
                    },
                    {
                        'field'           : 'interval',
                        'tag'             : 'interval',
                        'short-help'      : 'Polling interval in seconds',
                        'optional'        : True,
                        'optional-for-no' : True,
                        'base-type'       : 'integer',
                        # minimum is 10s
                        'range'           : (10,100000)
                    },
                ),
                (
                    {
                        'token'           : 'trap',
                        'short-help'      : 'Enable trap',
                    },
                    {
                        'token'           : LINK_UP_DOWN_CLI,
                        'short-help'      : 'Link up/down notification',
                        'data'            : { 'trap' : LINK_UP_DOWN_CLI },
                        'doc'             : 'snmp|snmp-linkUpDown',
                    },
                    {
                        'field'           : 'interval',
                        'tag'             : 'interval',
                        'short-help'      : 'Polling interval in seconds',
                        'base-type'       : 'integer',
                    },
                ),
                (
                    {
                        'token'           : 'trap',
                        'short-help'      : 'Enable trap',
                    },
                    {
                        'token'           : oidstr.THERMAL_CMD,
                        'short-help'      : 'Thermal sensors',
                        'data'            : { 'trap' : oidstr.THERMAL_CMD },
                        'doc'             : 'snmp|snmp-sensor-thermal',
                    },
                    {
                        'field'           : 'name',
                        'short-help'      : 'Thermal sensor name; see "show environment"',
                        'type'            : 'enum',
                        'values'          : trap_sensor_name_tuple_get(oidstr.THERMAL_CMD),
                        'doc'             : 'snmp|+',
                    },
                    {
                    'choices': (
                        sensor_enum_status_cli_get(oidstr.THERMAL_STATUS),
                        sensor_all_status_cli_get(oidstr.THERMAL_STATUS),
                        sensor_threshold_cli_get(oidstr.THERMAL_CMD,
                                                 oidstr.THERMAL_TEMP,
                                                 'Trap on temperature',
                                                 Name_Help(name='min',
                                                            help='Trap if temperature falls below this value, in milliCelsius'),
                                                 Name_Help(name='max',
                                                            help='Trap if temperature rises above this value, in milliCelsius')),
                    )
                    }, # ending of thermal choices
                    {
                        'field'           : 'interval',
                        'tag'             : 'interval',
                        'short-help'      : 'Polling interval in seconds',
                        'optional'        : True,
                        'optional-for-no' : True,
                        'base-type'       : 'integer',
                        # minimum is 10s
                        'range'           : (10,100000)
                    },
                ),
                (
                    {
                        'token'           : 'trap',
                        'short-help'      : 'Enable trap',
                    },
                    {
                        'token'           : oidstr.FAN_CMD,
                        'short-help'      : 'Fan sensors',
                        'data'            : { 'trap' : oidstr.FAN_CMD },
                        'doc'             : 'snmp|snmp-sensor-fan',
                    },
                    {
                        'field'           : 'name',
                        'short-help'      : 'Fan sensor name; see "show environment"',
                        'type'            : 'enum',
                        'values'          : trap_sensor_name_tuple_get(oidstr.FAN_CMD),
                        'doc'             : 'snmp|+',
                    },
                    {
                    'choices': (
                        sensor_enum_status_cli_get(oidstr.FAN_STATUS),
                        sensor_all_status_cli_get(oidstr.FAN_STATUS),
                        sensor_threshold_cli_get(oidstr.FAN_CMD,
                                                 oidstr.FAN_RPM,
                                                 'Trap on fan speed rotations per minute',
                                                 Name_Help(name='min',
                                                            help='Trap if fan speed falls below this value, in rotations per minute'),
                                                 Name_Help(name='max',
                                                            help='Trap if fan speed rises above this value, in rotations per minute')),
                        sensor_threshold_cli_get(oidstr.FAN_CMD,
                                                 oidstr.FAN_PERCENTAGE,
                                                 'Trap on fan speed percentage',
                                                 Name_Help(name='min',
                                                            help='Trap if fan speed falls below this value, in percent'),
                                                 Name_Help(name='max',
                                                            help='Trap if fan speed rises above this value, in percent')),
                    )
                    }, # ending of fan choices
                    {
                        'field'           : 'interval',
                        'tag'             : 'interval',
                        'short-help'      : 'Polling interval in seconds',
                        'optional'        : True,
                        'optional-for-no' : True,
                        'base-type'       : 'integer',
                        # minimum is 10s
                        'range'           : (10,100000)
                    },
                ),
                (
                    {
                        'token'           : 'trap',
                        'short-help'      : 'Enable trap',
                    },
                    {
                        'token'           : oidstr.PSU_CMD,
                        'short-help'      : 'PSU sensors',
                        'data'            : { 'trap' : oidstr.PSU_CMD },
                        'doc'             : 'snmp|snmp-sensor-psu',
                    },
                    {
                        'field'           : 'name',
                        'short-help'      : 'PSU sensor name; see "show environment"',
                        'type'            : 'enum',
                        'values'          : trap_sensor_name_tuple_get(oidstr.PSU_CMD),
                        'doc'             : 'snmp|+',
                    },
                    {
                    'choices': (
                        sensor_enum_status_cli_get(oidstr.PSU_STATUS),
                        sensor_all_status_cli_get(oidstr.PSU_STATUS),
                        sensor_threshold_cli_get(oidstr.PSU_CMD,
                                                 oidstr.PSU_VIN,
                                                 'Trap on input voltage',
                                                 Name_Help(name='min',
                                                            help='Trap if input voltage falls below this value, in millivolts'),
                                                 Name_Help(name='max',
                                                            help='Trap if input voltage rises above this value, in millivolts')),
                        sensor_threshold_cli_get(oidstr.PSU_CMD,
                                                 oidstr.PSU_VOUT,
                                                 'Trap on output voltage',
                                                 Name_Help(name='min',
                                                            help='Trap if output voltage falls below this value, in millivolts'),
                                                 Name_Help(name='max',
                                                            help='Trap if output voltage rises above this value, in millivolts')),
                        sensor_threshold_cli_get(oidstr.PSU_CMD,
                                                 oidstr.PSU_IIN,
                                                 'Trap on input current',
                                                 Name_Help(name='min',
                                                            help='Trap if input current falls below this value, in milliamperes'),
                                                 Name_Help(name='max',
                                                            help='Trap if input current rises above this value, in milliamperes')),
                        sensor_threshold_cli_get(oidstr.PSU_CMD,
                                                 oidstr.PSU_IOUT,
                                                 'Trap on output current',
                                                 Name_Help(name='min',
                                                            help='Trap if output current falls below this value, in milliamperes'),
                                                 Name_Help(name='max',
                                                            help='Trap if output current rises above this value, in milliamperes')),
                        sensor_threshold_cli_get(oidstr.PSU_CMD,
                                                 oidstr.PSU_PIN,
                                                 'Trap on input power',
                                                 Name_Help(name='min',
                                                            help='Trap if input power falls below this value, in milliwatts'),
                                                 Name_Help(name='max',
                                                            help='Trap if input power rises above this value, in milliwatts')),
                        sensor_threshold_cli_get(oidstr.PSU_CMD,
                                                 oidstr.PSU_POUT,
                                                 'Trap on output power',
                                                 Name_Help(name='min',
                                                            help='Trap if output power falls below this value, in milliwatts'),
                                                 Name_Help(name='max',
                                                            help='Trap if output power rises above this value, in milliwatts')),
                    ),
                    }, # ending of psu choices
                    {
                        'field'           : 'interval',
                        'tag'             : 'interval',
                        'short-help'      : 'Polling interval in seconds',
                        'optional'        : True,
                        'optional-for-no' : True,
                        'base-type'       : 'integer',
                        # minimum is 10s
                        'range'           : (10,100000)
                    },
                ),
                (
                    {
                        'token'           : 'trap',
                        'short-help'      : 'Enable trap',
                    },
                    {
                        'token'           : AUTH_FAIL_CLI,
                        'short-help'      : 'Authentication failure notification',
                        'data'            : { 'trap' : AUTH_FAIL_CLI },
                        'doc'             : 'snmp|snmp-authFail',
                    },
                ),
            ), # snmp choices: enable, host, location, trap
        },
    ),
}


def running_config_snmp(context, runcfg, words):
    comp_runcfg = []

    try:
        with cfgfile.FileLock(Snmp.CFG_PATH) as f:
            lines = cfgfile.get_line_list_from_file(f)
    except:
        raise error.ActionError('Cannot access SNMP configuration')
    cfg = parse_snmpd_conf(lines)

    # collect component-specific config
    if get_snmp_status() == 'enabled':
        comp_runcfg.append('snmp-server enable\n')
    if 'location' in cfg:
        comp_runcfg.append('snmp-server location %s\n' %
                           utif.quote_string(cfg['location'][0]))
    if 'contact' in cfg:
        comp_runcfg.append('snmp-server contact %s\n' %
                           utif.quote_string(cfg['contact'][0]))

    for li in lines:
        w = li[0:-1].split(' ')
        if w[0] in ('rocommunity', 'rwcommunity'):
            comp_runcfg.append('snmp-server community %s %s\n' %
                               (w[0][0:2], w[1])
                               )
            continue
        if w[0] == 'trap2sink':
            ww = w[1].split(':')
            comp_runcfg.append('snmp-server host %s traps %s udp-port %s\n' %
                               (ww[0], w[2], ww[1])
                               )
            continue
        if w[0] == 'informsink':
            ww = w[1].split(':')
            comp_runcfg.append('snmp-server host %s informs %s udp-port %s\n' %
                               (ww[0], w[2], ww[1])
                               )
            continue
        if w[0] == 'authtrapenable' and \
                len(w) == AUTH_FAIL_NOTIFICATION_TOKEN_NUM and w[1] == '1':
            comp_runcfg.append('snmp-server trap %s\n' % (AUTH_FAIL_CLI))
            continue
        if w[0] == 'monitor' and len(w) == LINK_UP_MONITOR_TOKEN_NUM:
            # The command linkUpDown results 2 monitor commands
            # and we print only 1 of them
            if w[4] == 'linkUpTrap':
                comp_runcfg.append('snmp-server trap %s interval %s\n' %
                                   (LINK_UP_DOWN_CLI, w[2])
                                  )
            # Skip another
            continue
        if w[0] == 'monitor':
            monitor_name_idx = 2
            interval_suffix  = ""
            if w[1] == '-r':
                monitor_name_idx = 4
                interval_suffix  = " interval %s" % (w[2])

            trap_cmd = w[monitor_name_idx].replace("_", " ")
            comp_runcfg.append('snmp-server trap %s%s\n' %
                               (trap_cmd, interval_suffix))

            continue
        
    # attach component-specific config
    if len(comp_runcfg) > 0:
        runcfg.append('!\n')
        runcfg += comp_runcfg

snmp_running_config_tuple = (
    (
        {
            'optional'   : False,
            'field'      : 'running-config',
            'type'       : 'enum',
            'values'     : 'snmp-server',
            'short-help' : 'Configuration for SNMP',
            'doc'        : 'running-config|show-snmp',
        },
    ),
)

run_config.register_running_config('snmp-server', 3000,  None,
                                   running_config_snmp,
                                   snmp_running_config_tuple)

