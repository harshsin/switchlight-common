#!/bin/sh
############################################################
#
# ztn-functions
#
# Support libraries for ZTN tools.
#
############################################################

#
# Are there any custom ZTN settings?
#
if [ -f /etc/ZTN ]; then
    . /etc/ZTN
fi

if [ "$ZTNDEBUG" ]; then
    set -x
fi

#
# Are we currently running in the loader environment?
#
ZTN_IN_LOADER=
if [ -f /etc/LOADER ]; then
    ZTN_IN_LOADER=1
fi

#
# The ZTN data files are stored here.
# Overrideable for testing.
#
ZTN_ROOT_DIR=${ZTN_ROOT:-/mnt/flash2/ztn}

#
# The ZTN cache is stored here
#
ZTN_CACHE_DIR=${ZTN_ROOT_DIR}/cache

#
# Make sure the ZTN root is always initialized.
#
mkdir -p ${ZTN_CACHE_DIR} || exit 1

#
# The latest ZTN manifest is always stored here
#
ZTN_MANIFEST=${ZTN_ROOT_DIR}/manifest.json

#
# Controls how long discovery waits for neighbor responses (in seconds)
#
ZTN_DISCOVERY_RESPONSE_WAIT=${ZTN_DISCOVERY_RESPONSE_WAIT:-0}


#
# This is the default timeout for ZTN Manifest Transactions
#
ZTN_MANIFEST_TIMEOUT=${ZTN_MANIFEST_TIMEOUT:-4}

#
# This is the default timeout for ZTN image download transactions
#
ZTN_DOWNLOAD_TIMEOUT=${ZTN_DOWNLOAD_TIMEOUT:-120}



#
# If the ZTN cache filesystem contains
# less than this amount of free space (in 1K blocks)
# before we attempt to download a new SWI
# then the cache will be cleared automatically
# before continuing.
#
ZTN_CACHE_PROVISION_MB=${ZTN_CACHE_PROVISION_MB:-250}

##############################
#
# ztn_cache_freem
#
ztn_cache_freem()
{
    # We request in 1K blocks to standardize output
    local freek=$(df -Pk "${ZTN_ROOT_DIR}" | tail -1 | awk '{print $4}')
    # Return in MB
    echo $((${freek}/1024))
}

##############################
#
# ztn_cache_provision
#
ztn_cache_provision()
{
    #
    # Todo: Allow provision size parameter.
    # If we add a filesize to the manifests
    # we can do better provisioning based on what
    # we are about to download rather than an arbitrary limit.
    #
    local freem=$(ztn_cache_freem)
    echo "ZTN Cache Free Memory: ${freem}M  [ Required: ${ZTN_CACHE_PROVISION_MB}M ]"
    if [ "${freem}" -lt "${ZTN_CACHE_PROVISION_MB}" ]; then
        #
        # We could do something more interesting here, like LRU and partial
        # deletes but there is really no expectation that the previous contents
        # of the cache will really ever be referenced again.
        #
        echo "The cache has insufficient space for additional images and will be cleared."
        ztn_cache_delete
    fi
}

##############################
#
# ztn_init
#
# Initialize the ZTN infrastructure.
#
##############################
ztn_init()
{
    :
}




##############################
#
# ztn_wget <dst> <url> <silent> <timeout>
#
# Perform a wget operation with
# timeout and cleanup.
#
ztn_wget()
{
    local dst=$1
    local url=$2
    local timeout=$3
    local silent=$4

    local rv=0
    local targs

    if [ "$ZTN_IN_LOADER" ]; then
        targs="-t${timeout}"
    else
        targs="${timeout}"
    fi

    if [ "$silent" ]; then
        if test -x /usr/bin/python; then
            timeout "$targs" /usr/bin/python /lib/ztn/wget.py "${dst}" "${url}" > /dev/null 2>&1
        else
            timeout "$targs" wget -O "${dst}" "${url}" > /dev/null 2>&1
        fi
    else
        if test -x /usr/bin/python; then
            timeout "$targs" /usr/bin/python /lib/ztn/wget.py "${dst}" "${url}"
        else
            timeout "$targs" wget -O "${dst}" "${url}"
        fi
    fi

    rv=$?

    if [ $rv -eq 124 ] || [ $rv -eq 143 ]; then
        echo "Operation timed out after ${timeout} seconds."
        if [ "$ZTN_IN_LOADER" ]; then
            killall -9 wget > /dev/null 2>&1
        fi
    fi

    return $rv
}



##############################
#
# ztn_cache_dir <class> <key> <mkdir>
#    <class> The cache class
#    <key>   The cache key
#    <mkdir> The cache key directory will be created if necessary.
#
ztn_cache_dir()
{
    local dir="${ZTN_CACHE_DIR}/${1}/${2}"
    if [ "${3}" ]; then
        mkdir -p "${dir}"
    fi
    echo ${dir}
}
##############################
#
# ztn_cache_delete
#
# Delete the entire ZTN cache
#
ztn_cache_delete()
{
    local rv
    rm -rf ${ZTN_ROOT_DIR}
    rv=$?
    if [ $rv -ne 0 ]; then
        echo "ZTN cache delete failed."
    fi
    mkdir -p ${ZTN_CACHE_DIR}
    sync
    return $rv
}


##############################
#
# ztn_cache_remove <class> <key>
#     <class> The cache class
#     <key>   The cache key
#
#     Remove the a directory in the cache.
#
ztn_cache_remove()
{
    local dir=$(ztn_cache_dir $1 $2)
    rm -rf ${dir}
}

##############################
#
# ztn_key <file>
#    <file> The file
#
#    Returns the hash key for the given file.
#
ztn_key()
{
    md5sum $1 | awk '{print $1}'
}

##############################
#
# ztn_cache_path <class> <key>
#    <key>  The key
#    <mkdir> Make the key directory as well.
#
#     Returns the cannonical file location
#     for an object stored in the cache.
#
ztn_cache_path()
{
    local class=$1
    local key=$2
    local mkdir=$3
    local hdir=$(ztn_cache_dir ${class} ${key} ${mkdir})
    echo "${hdir}/${key}.${class}"
}

##############################
#
# ztn_cache_install_local <class> <file> <key>
#     <class>
#     <file>      Local filename
#     <key>       Hash key if available otherwise calculated.
#
#     Install the given local file into the cache. This will
#     override any existing data.
#
ztn_cache_install_local()
{
    local class=$1
    local file=$2
    local key=${3:-$(ztn_key ${file})}
    local path=$(ztn_cache_path ${class} ${key} 1)
    cp ${file} ${path}
    sync
}

##############################
#
# ztn_cache_find <class> <key>
#    <class> The class
#    <key>   The key
#
ztn_cache_find()
{
    local path=$(ztn_cache_path $1 $2)
    if [ -e "${path}" ]; then
        echo "${path}"
    fi
}


##############################
#
# ztn_cache_class_inventory <class>
#
# Show the object inventory for the current class.
#
# Please Note:
# The output format must be YAML.
# Other tools depend on this.
#
ztn_cache_class_inventory()
{
    local class=$1

    keys=$(ls ${ZTN_CACHE_DIR}/${class})

    for k in ${keys}; do
        path=$(ztn_cache_path ${class} ${k})
        if [ "${path}" ]; then
            echo "  ${k} :"
            echo "    date : \"$(date --rfc-3339=seconds -r $path)\""
            echo "    path : \"${path}\""
            if [ -e "${path}.url" ]; then
                echo "    url : \"$(cat ${path}.url)\""
            else
                echo "*** missing ${path}.url" 1>&2
            fi
        fi
    done
}

##############################
#
# ztn_cache_inventory
#
# Show the object inventory for all classes.
#
ztn_cache_inventory()
{
    classes=$(ls ${ZTN_CACHE_DIR})

    for k in ${classes}; do
        echo "${k} :"
        ztn_cache_class_inventory $k
        echo
    done
}

##############################
#
# ztn_download_url <url> <localdst>
#   <url>  The file url
#   <localdst> The local file
ztn_download_url()
{
    local url=$1
    local localdst=$2

    case "${url}" in
        http:*|ftp:*)
            echo "Downloading ${url}...."
            if ! ztn_wget "${localdst}" "${url}" ${ZTN_DOWNLOAD_TIMEOUT}; then
                return 2
            fi
            ;;
        *)
            echo "Unsupported URL ${url}"
            return 1
            ;;
    esac
}

##############################
#
# ztn_cache_install_url <class> <url> <key>
#     <class> The class
#     <url> The url
#     <key> The expected key (verified)
#
# Download a file and store it in the cache.
#
ztn_cache_install_url()
{
    local class=$1
    local url=$2
    local key=$3
    local path
    local rmpath

    # Special case local files so we don't have multiple copies
    if [ -e "${url}" ]; then
        path="${url}"
    else
        path=$(mktemp)
        rmpath=1
        ztn_download_url "${url}" "${path}"
        test $? -eq 0 || return 2
    fi

    local dlkey=$(ztn_key ${path})
    key=${key:-${dlkey}}

    if [ "${key}" = "${dlkey}" ]; then
        ztn_cache_install_local ${class} ${path}
        echo "New ${class} ${key} installed..."
            # Record the source URL
        echo "${url}" > "$(ztn_cache_find ${class} ${key}).url"
    else
        echo "  Key mismatch for the downloaded ${class}. The ${class} was not installed."
        echo "    Expected: ${key}"
        echo "    Received: ${dlkey}"
    fi

    if [ "$rmpath" ]; then
        rm -rf "${path}"
    fi
}


##############################
#
# ztn_manifest_valid
#
ztn_manifest_valid()
{
    man=${1:-${ZTN_MANIFEST}}
    jq -M -r .not_a_key ${man} 1>/dev/null 2>&1
    return $?
}

##############################
#
# ztn_manifest_key_get
#
ztn_manifest_key_get()
{
    key=$1
    man=${2:-${ZTN_MANIFEST}}
    val=$(jq -M -r $key ${man})
    # Return nothing for missing keys, not 'null'
    if [ "${val}" != "null" ]; then
        echo ${val}
    fi
}

##############################
#
# ztn_manifest_swi_md5
#
ztn_manifest_swi_md5()
{
    echo $(ztn_manifest_key_get '.swi_md5' $1)
}

##############################
#
# ztn_manifest_startup_key_get()
#
ztn_manifest_startup_md5()
{
    echo $(ztn_manifest_key_get '.startup_config_md5' $1)
}


##############################
#
# ztn_transact_url <murl>
#
# Download a ZTN SWI manifest and its components.
# Return '0' for success (discovery can cease)
# Return '2' for undetermined (continue discovery)
# Anything else is an error
#

ztn_transact_url()
{
    local murl=$1
    local swi_url_mf swi_md5_mf
    local cfg_url_mf cfg_md5_mf

    local manifest=$(mktemp)
    if [ -e "${murl}" ]; then
        cp "${murl}" "${manifest}"
    else
        echo "Trying manifest ${murl}"
        ztn_wget "${manifest}" "$murl" ${ZTN_MANIFEST_TIMEOUT} 1
        test $? -eq 0 || return 2
    fi

    if ! ztn_manifest_valid ${manifest}; then
        echo "Not a valid manifest (invalid json), continuing..."
        return 2
    fi

    echo "Discovered Switch Light manifest from url $murl"
    swi_url_mf=$(ztn_manifest_key_get '.swi_url' ${manifest})

    # Is there a SWI specified?
    if [ "${swi_url_mf}" ]; then
        swi_md5_mf=$(ztn_manifest_swi_md5 ${manifest})
        # Do we already have this SWI?
        if [ "$(ztn_cache_find swi ${swi_md5_mf})" ]; then
            # We aleady have it
            echo "SWI ${swi_md5_mf} is already cached."
        else
            # Go get it.
            # Provision if necessary.
            ztn_cache_provision
            echo "Downloading new SWI..."
            if ! ztn_cache_install_url swi ${swi_url_mf} ${swi_md5_mf}; then
                return 2
            fi
        fi
    fi

    # Is there a startup config?
    cfg_url_mf=$(ztn_manifest_key_get '.startup_config_url' ${manifest})
    if [ "$cfg_url_mf" ]; then
        cfg_md5_mf=$(ztn_manifest_startup_md5 ${manifest})
        # Do we already have this startup-config?
        if [ "$(ztn_cache_find startup-config ${cfg_md5_mf})" ]; then
            # We already have it
            echo "startup-config ${cfg_md5_mf} is already cached."
        else
            # Go get it
            echo "Downloading startup-config..."
            if ! ztn_cache_install_url startup-config ${cfg_url_mf} ${cfg_md5_mf}; then
                return 2
            fi
        fi
    fi

    # Save the current manifest
    mv ${manifest} ${ZTN_MANIFEST}
    return 0
}


##############################
#
# ztn_manifest_validate <only-failures>
#
#    Returns whether the latest manifest file and its contents are valid.
#
ztn_manifest_validate()
{
    if [ -e "${ZTN_MANIFEST}" ]; then
        # Verify the SWI settings
        swi_md5=$(ztn_manifest_swi_md5)
        # This is required to be set and available
        if [ "$(ztn_cache_find swi ${swi_md5})" ]; then
            # Look for startup-config
            startup_md5=$(ztn_manifest_startup_md5)
            # This is optional
            if [ "${startup_md5}" ]; then
                if [ "$(ztn_cache_find startup-config ${startup_md5})" ]; then
                    if [ ! "$1" ]; then
                        echo "ZTN Manifest validated (SWI, startup-config)."
                    fi
                    return 0
                else
                    echo "The startup-config specified in the current manifest is missing."
                    echo "   ${startup_md5}"
                    return 1
                fi
            else
                # Startup-config key is missing from the manifest but otherwise its fine.
                if [ ! "$1" ]; then
                    echo "ZTN Manifest validated (SWI)."
                fi
                return 0
            fi
        else
            # The SWI key is missing or the SWI itself is missing, both bad.
            if [ "${swi_md5}" ]; then
                echo "The SWI specified in the current manifest is missing."
                echo "    ${swi_md5}"
            else
                echo "There is no SWI specified in the current manifest."
            fi
            return 1
        fi
    else
        # The manifest is missing
        echo "ZTN Manifest is missing."
        return 1
    fi
}

##############################
#
# ztn_manifest_url <h> <m> <p> <s>
#   <h>  Host
#   <m>  MAC Address
#   <p>  Platform
#   <s>  Serial Number
#
#   Returns a ZTN manifest URL.
#
ztn_manifest_url()
{
    echo "http://${1}/ztn/switch/${2}/switch_light_manifest?platform=${3}&serial=${4}"
}

##############################
#
# ztn_transact <h> <m> <p> <s>
#    <h>  Host
#    <m>  MAC Address
#    <p>  Platform
#    <s>  Serial Number
ztn_transact()
{
    ztn_transact_url $(ztn_manifest_url "$1" "$2" "$3" "$4")
}

##############################
#
# ztn_discovery_ex <intf> <mac> <platform> <serial>
#    <intf>      The interface on which to discover.
#    <platform>  The platform identifier.
#    <serial>    The system serial number.
#
# Perform ZTN neighbor discovery and process the resulting manifest
# using the values provided by the caller.
#
# This function will:
# 1. Discover a neighboring and responding ZTN server.
# 2. Process the resulting manifest.
#
# IF this function succeeds then we have downloaded and
# validated everthing required to boot.
#
ztn_discovery_ex()
{
    local intf=$1
    local macaddr=$2
    local platform=$3
    local serial=$4

    # borrow liberally from ONIE (rootconf/default/bin/discover)
    # ha ha, the wget IPv6 link local syntax is screwy
    # (and also does not match upstream GNU wget)
    ping6 -I ${intf} -c 3 ff02::1 > /dev/null 2>&1
    ping -I ${intf} -w 2 -c 3 -q 255.255.255.255 > /dev/null 2>&1

    if [ "${ZTN_DISCOVERY_RESPONSE_WAIT}" ]; then
        # The amount of time to wait for responses
        sleep "${ZTN_DISCOVERY_RESPONSE_WAIT}"
    fi

    neighs6=$(ip -6 neigh show | awk '{printf("%s%%'$intf'\n", $1)}')
    neighs=$(ip -4 neigh show | awk '{print $1}')

    for a in $neighs6 $neighs; do
        ztn_transact ${a} ${macaddr} ${platform} ${serial} && return 0
    done

    return 1
}

##############################
#
# ztn_discovery <intf> <platform> <serial>
#
ztn_discovery()
{
    if ifconfig ${1} > /dev/null 2>&1; then
        local macaddr=$(ifconfig ${1} | awk '/HWaddr/ { print tolower($5) }')
        ztn_discovery_ex $1 ${macaddr} $2 $3
    fi
}

##############################
#
# ztn_swi_get
#
#   Returns the path to the SWI we should
#   currently be booting according to
#   the latest downloaded manifest.
#
#   You cannot reliably use the result unless you call ztn_manifest_validate() first.
#
ztn_swi_get()
{
    # Get the key from the manifest
    key=$(ztn_manifest_swi_md5)
    echo $(ztn_cache_find swi ${key})
}

##############################
#
# ztn_startup_get
#
#   Returns the path to the startup-config we should
#   currently load according to the latest
#   downloaded manifest.
#
#   You cannot reliably use the result unless you call ztn_manifest_validate() first.
#
ztn_startup_get()
{
    # Get the key from the manifest
    key=$(ztn_manifest_startup_md5)
    echo $(ztn_cache_find startup-config ${key})
}

